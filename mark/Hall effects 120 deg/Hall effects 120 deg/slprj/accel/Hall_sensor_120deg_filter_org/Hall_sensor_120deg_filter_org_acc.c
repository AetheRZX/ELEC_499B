#include "Hall_sensor_120deg_filter_org_acc.h"
#include <stddef.h>
#include "rtwtypes.h"
#include "Hall_sensor_120deg_filter_org_acc_types.h"
#include "Hall_sensor_120deg_filter_org_acc_private.h"
#include "mwmathutil.h"
#include <string.h>
#include "simstruc_types.h"
#include <stdio.h>
#include "slexec_vm_simstruct_bridge.h"
#include "slexec_vm_zc_functions.h"
#include "slexec_vm_lookup_functions.h"
#include "slsv_diagnostic_codegen_c_api.h"
#include "simtarget/slSimTgtMdlrefSfcnBridge.h"
#include "simstruc.h"
#include "fixedpoint.h"
#define CodeFormat S-Function
#define AccDefine1 Accelerator_S-Function
#include "simtarget/slAccSfcnBridge.h"
#ifndef __RTW_UTFREE__  
extern void * utMalloc ( size_t ) ; extern void utFree ( void * ) ;
#endif
boolean_T Hall_sensor_120deg_filter_org_acc_rt_TDelayUpdateTailOrGrowBuf ( int_T
* bufSzPtr , int_T * tailPtr , int_T * headPtr , int_T * lastPtr , real_T
tMinusDelay , real_T * * uBufPtr , boolean_T isfixedbuf , boolean_T
istransportdelay , int_T * maxNewBufSzPtr ) { int_T testIdx ; int_T tail = *
tailPtr ; int_T bufSz = * bufSzPtr ; real_T * tBuf = * uBufPtr + bufSz ;
real_T * xBuf = ( NULL ) ; int_T numBuffer = 2 ; if ( istransportdelay ) {
numBuffer = 3 ; xBuf = * uBufPtr + 2 * bufSz ; } testIdx = ( tail < ( bufSz -
1 ) ) ? ( tail + 1 ) : 0 ; if ( ( tMinusDelay <= tBuf [ testIdx ] ) && !
isfixedbuf ) { int_T j ; real_T * tempT ; real_T * tempU ; real_T * tempX = ( NULL ) ; real_T * uBuf = * uBufPtr ; int_T newBufSz = bufSz + 1024 ; if ( newBufSz > * maxNewBufSzPtr ) { * maxNewBufSzPtr = newBufSz ; } tempU = ( real_T * ) utMalloc ( numBuffer * newBufSz * sizeof ( real_T ) ) ; if ( tempU == ( NULL ) ) { return ( false ) ; } tempT = tempU + newBufSz ; if ( istransportdelay ) tempX = tempT + newBufSz ; for ( j = tail ; j < bufSz ; j ++ ) { tempT [ j - tail ] = tBuf [ j ] ; tempU [ j - tail ] = uBuf [ j ] ; if ( istransportdelay ) tempX [ j - tail ] = xBuf [ j ] ; } for ( j = 0 ; j < tail ; j ++ ) { tempT [ j + bufSz - tail ] = tBuf [ j ] ; tempU [ j + bufSz - tail ] = uBuf [ j ] ; if ( istransportdelay ) tempX [ j + bufSz - tail ] = xBuf [ j ] ; } if ( * lastPtr > tail ) { * lastPtr -= tail ; } else { * lastPtr += ( bufSz - tail ) ; } * tailPtr = 0 ; * headPtr = bufSz ; utFree ( uBuf ) ; * bufSzPtr = newBufSz ; * uBufPtr = tempU ; } else { * tailPtr = testIdx ; } return ( true ) ; } real_T Hall_sensor_120deg_filter_org_acc_rt_VTDelayfindtDInterpolate ( real_T x , real_T * uBuf , int_T bufSz , int_T head , int_T tail , int_T * pLast , real_T t , real_T tStart , boolean_T discrete , boolean_T minorStepAndTAtLastMajorOutput , real_T initOutput , real_T * appliedDelay ) { int_T n , k ; real_T f ; int_T kp1 ; real_T tminustD = 0 ; real_T tL = 0 ; real_T tR = 0 ; real_T uL = 0 ; real_T uR = 0 ; real_T uD , fU ; real_T * tBuf = uBuf + bufSz ; real_T * xBuf = uBuf + 2 * bufSz ; if ( minorStepAndTAtLastMajorOutput ) { if ( * pLast == head ) { * pLast = ( * pLast == 0 ) ? bufSz - 1 : * pLast - 1 ; } head = ( head == 0 ) ? bufSz - 1 : head - 1 ; } if ( x <= 1 ) { return initOutput ; } k = * pLast ; n = 0 ; for ( ; ; ) { n ++ ; if ( n > bufSz ) break ; if ( x - xBuf [ k ] > 1.0 ) { if ( k == head ) { int_T km1 ; f = ( x - 1.0 - xBuf [ k ] ) / ( x - xBuf [ k ] ) ; tminustD = ( 1.0 - f ) * tBuf [ k ] + f * t ; km1 = k - 1 ; if ( km1 < 0 ) km1 = bufSz - 1 ; tL = tBuf [ km1 ] ; tR = tBuf [ k ] ; uL = uBuf [ km1 ] ; uR = uBuf [ k ] ; break ; } kp1 = k + 1 ; if ( kp1 == bufSz ) kp1 = 0 ; if ( x - xBuf [ kp1 ] <= 1.0 ) { f = ( x - 1.0 - xBuf [ k ] ) / ( xBuf [ kp1 ] - xBuf [ k ] ) ; tL = tBuf [ k ] ; tR = tBuf [ kp1 ] ; uL = uBuf [ k ] ; uR = uBuf [ kp1 ] ; tminustD = ( 1.0 - f ) * tL + f * tR ; break ; } k = kp1 ; } else { if ( k == tail ) { f = ( x - 1.0 ) / xBuf [ k ] ; if ( discrete ) { return ( uBuf [ tail ] ) ; } kp1 = k + 1 ; if ( kp1 == bufSz ) kp1 = 0 ; tminustD = ( 1 - f ) * tStart + f * tBuf [ k ] ; tL = tBuf [ k ] ; tR = tBuf [ kp1 ] ; uL = uBuf [ k ] ; uR = uBuf [ kp1 ] ; break ; } k = k - 1 ; if ( k < 0 ) k = bufSz - 1 ; } } * pLast = k ; if ( tR == tL ) { fU = 1.0 ; } else { fU = ( tminustD - tL ) / ( tR - tL ) ; } if ( discrete ) { uD = ( fU > ( 1.0 - fU ) ) ? uR : uL ; } else { uD = ( 1.0 - fU ) * uL + fU * uR ; } * appliedDelay = t - tminustD ; return uD ; } void rt_ssGetBlockPath ( void * S , int_T sysIdx , int_T blkIdx , char_T * * path ) { _ssGetBlockPath ( ( SimStruct * ) S , sysIdx , blkIdx , path ) ; } void rt_ssSet_slErrMsg ( void * S , void * diag ) { SimStruct * castedS = ( SimStruct * ) S ; if ( ! _ssIsErrorStatusAslErrMsg ( castedS ) ) { _ssSet_slErrMsg ( castedS , diag ) ; } else { _ssDiscardDiagnostic ( castedS , diag ) ; } } void rt_ssReportDiagnosticAsWarning ( void * S , void * diag ) { _ssReportDiagnosticAsWarning ( ( SimStruct * ) S , diag ) ; } void rt_ssReportDiagnosticAsInfo ( void * S , void * diag ) { _ssReportDiagnosticAsInfo ( ( SimStruct * ) S , diag ) ; } static void mdlOutputs ( SimStruct * S , int_T tid ) { real_T B_25_174_1368 ; real_T B_25_188_1480 ; B_Hall_sensor_120deg_filter_org_T * _rtB ; DW_Hall_sensor_120deg_filter_org_T * _rtDW ; P_Hall_sensor_120deg_filter_org_T * _rtP ; PrevZCX_Hall_sensor_120deg_filter_org_T * _rtZCE ; X_Hall_sensor_120deg_filter_org_T * _rtX ; real_T rtb_B_25_173_1360 ; real_T rtb_B_25_187_1472 ; real_T tmp ; real_T u0 ; int32_T isHit ; boolean_T rtb_B_25_236_1864 ; ZCEventType zcEvent ; _rtDW = ( ( DW_Hall_sensor_120deg_filter_org_T * ) ssGetRootDWork ( S ) ) ; _rtZCE = ( ( PrevZCX_Hall_sensor_120deg_filter_org_T * ) _ssGetPrevZCSigState ( S ) ) ; _rtX = ( ( X_Hall_sensor_120deg_filter_org_T * ) ssGetContStates ( S ) ) ; _rtP = ( ( P_Hall_sensor_120deg_filter_org_T * ) ssGetModelRtp ( S ) ) ; _rtB = ( ( B_Hall_sensor_120deg_filter_org_T * ) _ssGetModelBlockIO ( S ) ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_0_0 = _rtDW -> DiscreteTimeIntegrator2_DSTATE ; _rtB -> B_25_1_8 = _rtB -> B_25_0_0 / _rtB -> B_25_99_792 ; _rtB -> B_25_2_16 = _rtDW -> DiscreteTimeIntegrator1_DSTATE ; _rtB -> B_25_3_24 = ( _rtB -> B_25_2_16 - _rtB -> B_25_101_808 ) / _rtB -> B_25_100_800 ; } _rtB -> B_25_4_32 = _rtX -> Integrator_CSTATE ; ssCallAccelRunBlock ( S , 8 , 0 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 23 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { ssCallAccelRunBlock ( S , 25 , 8 , SS_CALL_MDL_OUTPUTS ) ; } ssCallAccelRunBlock ( S , 25 , 9 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 10 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 11 , SS_CALL_MDL_OUTPUTS ) ; _rtB -> B_25_32_256 = 0.0 ; _rtB -> B_25_32_256 += _rtP -> P_35 * _rtX -> MechSystem_CSTATE ; _rtB -> B_25_33_264 = _rtP -> P_36 * _rtB -> B_25_32_256 ; ssCallAccelRunBlock ( S , 25 , 14 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_34_272 = _rtP -> P_37 * _rtB -> B_25_1_8 ; ssCallAccelRunBlock ( S , 25 , 16 , SS_CALL_MDL_OUTPUTS ) ; } _rtB -> B_25_35_280 = _rtP -> P_38 * _rtB -> B_25_32_256 ; ssCallAccelRunBlock ( S , 6 , 0 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 19 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { ssCallAccelRunBlock ( S , 25 , 20 , SS_CALL_MDL_OUTPUTS ) ; } ssCallAccelRunBlock ( S , 1 , 0 , SS_CALL_MDL_OUTPUTS ) ; _rtB -> B_25_36_288 = _rtP -> P_39 * _rtB -> B_1_166_1328 ; if ( _rtB -> B_25_36_288 > _rtP -> P_40 ) { rtb_B_25_173_1360 = _rtP -> P_40 ; } else if ( _rtB -> B_25_36_288 < _rtP -> P_41 ) { rtb_B_25_173_1360 = _rtP -> P_41 ; } else { rtb_B_25_173_1360 = _rtB -> B_25_36_288 ; } _rtB -> B_25_37_296 = _rtX -> Integrator_CSTATE_n ; { real_T * * uBuffer = ( real_T * * ) & _rtDW -> VariableTransportDelay_PWORK . TUbufferPtrs [ 0 ] ; real_T simTime = ssGetT ( S ) ; real_T appliedDelay ; B_25_174_1368 = Hall_sensor_120deg_filter_org_acc_rt_VTDelayfindtDInterpolate ( _rtX -> VariableTransportDelay_CSTATE , * uBuffer , _rtDW -> VariableTransportDelay_IWORK . CircularBufSize , _rtDW -> VariableTransportDelay_IWORK . Head , _rtDW -> VariableTransportDelay_IWORK . Tail , & _rtDW -> VariableTransportDelay_IWORK . Last , simTime , 0.0 , 0 , ( boolean_T ) ( ssIsMinorTimeStep ( S ) && ( ( * uBuffer + _rtDW -> VariableTransportDelay_IWORK . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK . Head ] == ssGetT ( S ) ) ) , _rtP -> P_44 , & appliedDelay ) ; } rtb_B_25_236_1864 = ( ssGetT ( S ) >= _rtB -> B_25_97_776 ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_38_304 = _rtDW -> Memory_PreviousInput ; } if ( rtb_B_25_236_1864 ) { _rtB -> B_25_39_312 = ( _rtB -> B_25_37_296 - B_25_174_1368 ) * rtb_B_25_173_1360 ; } else { _rtB -> B_25_39_312 = _rtB -> B_25_38_304 ; } ssCallAccelRunBlock ( S , 25 , 31 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 32 , SS_CALL_MDL_OUTPUTS ) ; if ( ssGetTaskTime ( S , 0 ) < _rtP -> P_46 ) { u0 = _rtP -> P_47 ; } else { u0 = _rtP -> P_48 ; } _rtB -> B_25_40_320 = ( _rtB -> B_25_93_744 - _rtB -> B_25_39_312 * u0 ) * _rtP -> P_49 * _rtP -> P_50 ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_41_328 = ( _rtP -> P_54 * _rtB -> B_25_40_320 - _rtDW -> Filter_DSTATE ) * _rtP -> P_57 ; if ( _rtP -> P_132 == 1 ) { u0 = ( _rtP -> P_51 * _rtB -> B_25_40_320 + _rtDW -> Integrator_DSTATE ) + _rtB -> B_25_41_328 ; if ( u0 > _rtP -> P_58 ) { _rtB -> B_25_42_336 = _rtP -> P_58 ; } else if ( u0 < _rtP -> P_59 ) { _rtB -> B_25_42_336 = _rtP -> P_59 ; } else { _rtB -> B_25_42_336 = u0 ; } } else { _rtB -> B_25_42_336 = _rtB -> B_25_94_752 ; } ssCallAccelRunBlock ( S , 25 , 47 , SS_CALL_MDL_OUTPUTS ) ; } if ( _rtB -> B_25_36_288 > _rtP -> P_60 ) { rtb_B_25_187_1472 = _rtP -> P_60 ; } else if ( _rtB -> B_25_36_288 < _rtP -> P_61 ) { rtb_B_25_187_1472 = _rtP -> P_61 ; } else { rtb_B_25_187_1472 = _rtB -> B_25_36_288 ; } _rtB -> B_25_43_344 = _rtX -> Integrator_CSTATE_l ; { real_T * * uBuffer = ( real_T * * ) & _rtDW -> VariableTransportDelay_PWORK_j . TUbufferPtrs [ 0 ] ; real_T simTime = ssGetT ( S ) ; real_T appliedDelay ; B_25_188_1480 = Hall_sensor_120deg_filter_org_acc_rt_VTDelayfindtDInterpolate ( _rtX -> VariableTransportDelay_CSTATE_g , * uBuffer , _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize , _rtDW -> VariableTransportDelay_IWORK_n . Head , _rtDW -> VariableTransportDelay_IWORK_n . Tail , & _rtDW -> VariableTransportDelay_IWORK_n . Last , simTime , 0.0 , 0 , ( boolean_T ) ( ssIsMinorTimeStep ( S ) && ( ( * uBuffer + _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK_n . Head ] == ssGetT ( S ) ) ) , _rtP -> P_64 , & appliedDelay ) ; } rtb_B_25_236_1864 = ( ssGetT ( S ) >= _rtB -> B_25_98_784 ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_44_352 = _rtDW -> Memory_PreviousInput_d ; } if ( rtb_B_25_236_1864 ) { _rtB -> B_25_45_360 = ( _rtB -> B_25_43_344 - B_25_188_1480 ) * rtb_B_25_187_1472 ; } else { _rtB -> B_25_45_360 = _rtB -> B_25_44_352 ; } ssCallAccelRunBlock ( S , 25 , 56 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { ssCallAccelRunBlock ( S , 25 , 57 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 58 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 59 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 60 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 61 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 62 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 63 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 64 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 65 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 66 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 25 , 67 , SS_CALL_MDL_OUTPUTS ) ; } _rtB -> B_25_46_368 = ( _rtB -> B_25_105_840 + _rtB -> B_8_155_1240 ) + _rtB -> B_25_42_336 ; ssCallAccelRunBlock ( S , 10 , 0 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 2 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { { if ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction2_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction2_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_2_165_1320 + 0 ) ; } } } ssCallAccelRunBlock ( S , 9 , 0 , SS_CALL_MDL_OUTPUTS ) ; ssCallAccelRunBlock ( S , 0 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { { if ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_0_167_1336 + 0 ) ; } } { if ( _rtDW -> TAQSigLogging_InsertedFor_PMSM_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_PMSM_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_25_1_8 + 0 ) ; } } { if ( _rtDW -> TAQSigLogging_InsertedFor_PMSM_at_outport_2_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_PMSM_at_outport_2_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_25_32_256 + 0 ) ; } } } ssCallAccelRunBlock ( S , 13 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_m , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/Data Store Read3" , 0 ) ; _rtB -> B_25_47_376 = _rtDW -> reset_toggle ; if ( ( ( _rtB -> B_25_47_376 > 0.0 ) && ( _rtDW -> DiscreteTimeIntegrator1_PrevResetState <= 0 ) ) || ( ( _rtB -> B_25_47_376 <= 0.0 ) && ( _rtDW -> DiscreteTimeIntegrator1_PrevResetState == 1 ) ) ) { _rtDW -> DiscreteTimeIntegrator1_DSTATE_n = _rtP -> P_67 ; } _rtB -> B_25_48_384 = _rtDW -> DiscreteTimeIntegrator1_DSTATE_n ; } vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_n , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/Data Store Read" , 0 ) ; _rtB -> B_25_168_1344 = ( _rtB -> B_25_48_384 >= _rtDW -> tau_corr_now ) ; if ( _rtP -> P_133 == 1 ) { if ( ssGetTaskTime ( S , 0 ) < _rtP -> P_68 ) { _rtB -> B_25_49_392 = _rtP -> P_69 ; } else { _rtB -> B_25_49_392 = _rtP -> P_70 ; } } else { _rtB -> B_25_49_392 = _rtB -> B_25_95_760 ; } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_50_400 = _rtDW -> DelayInput1_DSTATE ; } _rtB -> B_25_169_1345 = ( _rtB -> B_13_146_1168 != _rtB -> B_25_50_400 ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { if ( ssIsModeUpdateTimeStep ( S ) ) { if ( _rtB -> B_25_169_1345 && ( _rtZCE -> hardware_ISR_routine_Trig_ZCE != POS_ZCSIG ) ) { _rtDW -> t_now = _rtB -> B_25_48_384 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_g , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Subsystem2/Data Store Write2" , 0 ) ; _rtB -> B_19_128_1024 = _rtDW -> Memory_PreviousInput_p ; _rtB -> B_19_129_1032 = _rtDW -> Memory1_PreviousInput ; _rtB -> B_19_130_1040 = _rtDW -> Memory2_PreviousInput ; _rtB -> B_19_131_1048 = _rtDW -> Memory3_PreviousInput ; _rtB -> B_19_132_1056 = _rtDW -> Memory4_PreviousInput ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_g , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Data Store Read" , 0 ) ; _rtB -> B_19_133_1064 = _rtDW -> t_now ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_n , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Data Store Read1" , 0 ) ; _rtB -> B_19_134_1072 = _rtDW -> tau_corr_now ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_h , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Data Store Read2" , 0 ) ; _rtB -> B_19_135_1080 = _rtDW -> tau_corr_next ; _rtB -> B_18_137_1096 [ 0 ] = _rtB -> B_19_133_1064 - _rtB -> B_19_128_1024 ; _rtB -> B_18_137_1096 [ 1 ] = _rtB -> B_19_128_1024 - _rtB -> B_19_129_1032 ; _rtB -> B_18_137_1096 [ 2 ] = _rtB -> B_19_129_1032 - _rtB -> B_19_130_1040 ; _rtB -> B_18_137_1096 [ 3 ] = _rtB -> B_19_130_1040 - _rtB -> B_19_131_1048 ; _rtB -> B_18_137_1096 [ 4 ] = _rtB -> B_19_131_1048 - _rtB -> B_19_132_1056 ; _rtB -> B_18_137_1096 [ 5 ] = _rtB -> B_19_132_1056 - _rtDW -> Memory5_PreviousInput ; ssCallAccelRunBlock ( S , 18 , 1 , SS_CALL_MDL_OUTPUTS ) ; _rtB -> B_19_136_1088 = _rtB -> B_25_49_392 ; if ( _rtB -> B_19_136_1088 > 0.0 ) { if ( _rtB -> B_18_170_1346 ) { _rtDW -> tau_corr_now = _rtB -> B_18_143_1144 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_n , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Atomic Subsystem/Subsystem/Data Store Write" , 0 ) ; _rtDW -> Subsystem_SubsysRanBC = 4 ; } if ( _rtB -> B_18_171_1347 ) { _rtDW -> tau_corr_next = _rtB -> B_18_144_1152 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_h , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/hardware_ISR_routine/Atomic Subsystem/Subsystem1/Data Store Write1" , 0 ) ; _rtDW -> Subsystem1_SubsysRanBC = 4 ; } _rtDW -> AtomicSubsystem_SubsysRanBC = 4 ; } _rtDW -> Memory_PreviousInput_p = _rtB -> B_19_133_1064 ; _rtDW -> Memory1_PreviousInput = _rtB -> B_19_128_1024 ; _rtDW -> Memory2_PreviousInput = _rtB -> B_19_129_1032 ; _rtDW -> Memory3_PreviousInput = _rtB -> B_19_130_1040 ; _rtDW -> Memory4_PreviousInput = _rtB -> B_19_131_1048 ; _rtDW -> Memory5_PreviousInput = _rtB -> B_19_132_1056 ; _rtDW -> hardware_ISR_routine_SubsysRanBC = 4 ; } _rtZCE -> hardware_ISR_routine_Trig_ZCE = _rtB -> B_25_169_1345 ; if ( _rtB -> B_25_168_1344 && ( _rtZCE -> software_ISR_routine_Trig_ZCE != POS_ZCSIG ) ) { vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_h , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem/Data Store Read" , 0 ) ; _rtDW -> tau_corr_now = _rtDW -> tau_corr_next ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_n , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem/Data Store Write" , 0 ) ; _rtDW -> first_time = _rtB -> B_21_123_984 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_l , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem4/Data Store Write" , 0 ) ; if ( ssIsMajorTimeStep ( S ) != 0 ) { ssSetBlockStateForSolverChangedAtMajorStep ( S ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( S ) ; } _rtDW -> tau_corr_next = _rtB -> B_21_124_992 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_h , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem1/Data Store Write1" , 0 ) ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_d , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem2/Data Store Read" , 0 ) ; _rtB -> B_21_121_968 = _rtDW -> state_out + _rtB -> B_21_125_1000 ; ssCallAccelRunBlock ( S , 20 , 0 , SS_CALL_MDL_OUTPUTS ) ; _rtDW -> state_out = _rtB -> B_20_127_1016 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_d , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem2/Data Store Write" , 0 ) ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_d , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/software_ISR_routine/Subsystem3/Data Store Read" , 0 ) ; _rtB -> B_21_122_976 = _rtDW -> state_out + _rtB -> B_21_126_1008 ; _rtDW -> software_ISR_routine_SubsysRanBC = 4 ; } _rtZCE -> software_ISR_routine_Trig_ZCE = _rtB -> B_25_168_1344 ; } ssCallAccelRunBlock ( S , 14 , 0 , SS_CALL_MDL_OUTPUTS ) ; } if ( _rtB -> B_25_49_392 > _rtP -> P_72 ) { vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_l , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/Data Store Read5" , 0 ) ; if ( _rtDW -> first_time > _rtP -> P_0 ) { _rtB -> B_25_51_408 = _rtB -> B_13_146_1168 ; } else { _rtB -> B_25_51_408 = _rtB -> B_14_145_1160 ; } } else { _rtB -> B_25_51_408 = _rtB -> B_0_167_1336 ; } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { { if ( _rtDW -> TAQSigLogging_InsertedFor_Switch3_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_Switch3_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_25_51_408 + 0 ) ; } } } if ( ssGetTaskTime ( S , 0 ) < _rtP -> P_73 ) { _rtB -> B_25_52_416 = _rtP -> P_74 ; } else { _rtB -> B_25_52_416 = _rtP -> P_75 ; } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { ssCallAccelRunBlock ( S , 25 , 94 , SS_CALL_MDL_OUTPUTS ) ; } if ( ssGetTaskTime ( S , 0 ) < _rtP -> P_76 ) { u0 = _rtP -> P_77 ; } else { u0 = _rtP -> P_78 ; } if ( ssGetTaskTime ( S , 0 ) < _rtP -> P_79 ) { tmp = _rtP -> P_80 ; } else { tmp = _rtP -> P_81 ; } _rtB -> B_25_53_424 = u0 + tmp ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { ssCallAccelRunBlock ( S , 25 , 98 , SS_CALL_MDL_OUTPUTS ) ; } _rtB -> B_25_54_432 = _rtB -> B_25_3_24 ; _rtB -> B_25_55_440 = 1.0 / rtb_B_25_173_1360 ; _rtB -> B_25_56_448 = 1.0 / rtb_B_25_187_1472 ; if ( _rtB -> B_25_88_704 > _rtP -> P_82 ) { u0 = _rtB -> B_25_52_416 ; } else { u0 = _rtB -> B_25_53_424 ; } if ( _rtB -> B_25_88_704 > _rtP -> P_83 ) { tmp = _rtB -> B_25_33_264 ; } else { tmp = _rtB -> B_25_34_272 ; } rtb_B_25_173_1360 = u0 - tmp ; _rtB -> B_25_57_456 = _rtP -> P_86 * rtb_B_25_173_1360 ; rtb_B_25_187_1472 = _rtX -> Integrator_CSTATE_j ; _rtB -> B_25_58_464 = ( _rtP -> P_84 * rtb_B_25_173_1360 - _rtX -> Filter_CSTATE ) * _rtP -> P_88 ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_59_472 = _rtP -> P_89 * _rtB -> B_25_40_320 ; } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_60_480 = _rtP -> P_90 * _rtB -> B_25_5_40 [ 12 ] ; _rtB -> B_25_61_488 = _rtP -> P_91 * _rtB -> B_25_5_40 [ 13 ] ; _rtB -> B_25_62_496 = _rtP -> P_92 * _rtB -> B_25_5_40 [ 14 ] ; } ssCallAccelRunBlock ( S , 24 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_63_504 = _rtP -> P_93 * _rtB -> B_25_1_8 ; } _rtB -> B_25_64_512 = ( _rtB -> B_24_116_928 - _rtB -> B_25_32_256 * _rtB -> B_25_2_16 ) - _rtB -> B_25_63_504 ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_65_520 = _rtP -> P_94 * _rtB -> B_25_3_24 ; } _rtB -> B_25_66_528 = ( _rtB -> B_25_0_0 * _rtB -> B_25_32_256 + _rtB -> B_24_117_936 ) - _rtB -> B_25_65_520 ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_67_536 = _rtB -> B_25_34_272 - _rtB -> B_25_96_768 ; } ssCallAccelRunBlock ( S , 7 , 0 , SS_CALL_MDL_OUTPUTS ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { if ( ssIsModeUpdateTimeStep ( S ) ) { zcEvent = rt_ZCFcn ( RISING_ZERO_CROSSING , & _rtZCE -> Firsttriggerinitialization_Trig_ZCE , _rtB -> B_25_49_392 ) ; if ( zcEvent != NO_ZCEVENT ) { ssCallAccelRunBlock ( S , 11 , 0 , SS_CALL_MDL_OUTPUTS ) ; _rtDW -> state_out = _rtB -> B_11_148_1184 - _rtB -> B_12_147_1176 ; vm_WriteLocalDSMNoIdx ( S , _rtDW -> dsmIdx_d , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/First trigger initialization/Data Store Write3" , 0 ) ; _rtDW -> Firsttriggerinitialization_SubsysRanBC = 4 ; } } ssCallAccelRunBlock ( S , 25 , 125 , SS_CALL_MDL_OUTPUTS ) ; { if ( _rtDW -> TAQSigLogging_InsertedFor_DetectChange_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_DetectChange_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_25_169_1345 + 0 ) ; } } { if ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction1_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_MATLABFunction1_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_14_145_1160 + 0 ) ; } } { if ( _rtDW -> TAQSigLogging_InsertedFor_RelationalOperator_at_outport_0_PWORK . AQHandles && ssGetLogOutput ( S ) ) { sdiWriteSignal ( _rtDW -> TAQSigLogging_InsertedFor_RelationalOperator_at_outport_0_PWORK . AQHandles , ssGetTaskTime ( S , 1 ) , ( char * ) & _rtB -> B_25_168_1344 + 0 ) ; } } ssCallAccelRunBlock ( S , 25 , 129 , SS_CALL_MDL_OUTPUTS ) ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_h , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/Data Store Read1" , 0 ) ; _rtB -> B_25_68_544 = _rtDW -> tau_corr_next ; ssCallAccelRunBlock ( S , 25 , 131 , SS_CALL_MDL_OUTPUTS ) ; vm_ReadLocalDSMNoIdx ( S , _rtDW -> dsmIdx_d , ( char_T * ) "Hall_sensor_120deg_filter_org/hall_filter/Data Store Read4" , 0 ) ; _rtB -> B_25_69_552 = _rtDW -> state_out ; ssCallAccelRunBlock ( S , 25 , 133 , SS_CALL_MDL_OUTPUTS ) ; } if ( _rtB -> B_25_114_912 > _rtP -> P_100 ) { rtb_B_25_173_1360 = ( _rtP -> P_14 * rtb_B_25_173_1360 + rtb_B_25_187_1472 ) + _rtB -> B_25_58_464 ; if ( rtb_B_25_173_1360 > _rtP -> P_15 ) { rtb_B_25_173_1360 = _rtP -> P_15 ; } else if ( rtb_B_25_173_1360 < _rtP -> P_16 ) { rtb_B_25_173_1360 = _rtP -> P_16 ; } } else { rtb_B_25_173_1360 = _rtB -> B_25_113_904 ; } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_70_560 = _rtP -> P_101 ; } rtb_B_25_187_1472 = ssGetT ( S ) + _rtB -> B_25_70_560 ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_71_568 = _rtP -> P_102 ; } rtb_B_25_236_1864 = ( ( rtb_B_25_173_1360 != Hall_sensor_120deg_filter_org_rtC ( S ) -> B_25_241_1872 ) && ( rtb_B_25_173_1360 >= ( ( _rtP -> P_103 * muDoubleScalarRem ( rtb_B_25_187_1472 , _rtB -> B_25_71_568 ) * 2.0 - 1.0 ) + 1.0 ) * 0.5 ) ) ; isHit = ssIsSampleHit ( S , 2 , 0 ) ; if ( isHit != 0 ) { _rtB -> B_25_72_576 = _rtDW -> UnitDelay_DSTATE ; } _rtB -> B_25_73_584 = ( real_T ) rtb_B_25_236_1864 * _rtB -> B_7_156_1248 [ 0 ] ; _rtB -> B_25_74_592 = ( real_T ) rtb_B_25_236_1864 * _rtB -> B_7_156_1248 [ 1 ] ; _rtB -> B_25_75_600 = ( real_T ) rtb_B_25_236_1864 * _rtB -> B_7_156_1248 [ 2 ] ; UNUSED_PARAMETER ( tid ) ; } static void mdlOutputsTID3 ( SimStruct * S , int_T tid ) { B_Hall_sensor_120deg_filter_org_T * _rtB ; P_Hall_sensor_120deg_filter_org_T * _rtP ; _rtP = ( ( P_Hall_sensor_120deg_filter_org_T * ) ssGetModelRtp ( S ) ) ; _rtB = ( ( B_Hall_sensor_120deg_filter_org_T * ) _ssGetModelBlockIO ( S ) ) ; memcpy ( & _rtB -> B_25_76_608 [ 0 ] , & _rtP -> P_105 [ 0 ] , 12U * sizeof ( real_T ) ) ; _rtB -> B_25_88_704 = _rtP -> P_106 ; _rtB -> B_25_92_736 = _rtP -> P_110 ; _rtB -> B_25_93_744 = _rtP -> P_111 ; _rtB -> B_25_94_752 = _rtP -> P_112 ; _rtB -> B_25_95_760 = _rtP -> P_113 ; _rtB -> B_25_96_768 = _rtP -> P_114 ; _rtB -> B_25_97_776 = _rtP -> P_115 ; _rtB -> B_25_98_784 = _rtP -> P_116 ; _rtB -> B_25_99_792 = _rtP -> P_117 ; _rtB -> B_25_100_800 = _rtP -> P_118 ; _rtB -> B_25_101_808 = _rtP -> P_119 ; _rtB -> B_25_89_712 [ 0 ] = _rtP -> P_108 [ 0 ] ; if ( _rtP -> P_109 > _rtP -> P_120 ) { _rtB -> B_25_102_816 [ 0 ] = _rtP -> P_107 [ 0 ] ; } else { _rtB -> B_25_102_816 [ 0 ] = _rtP -> P_108 [ 0 ] ; } _rtB -> B_25_89_712 [ 1 ] = _rtP -> P_108 [ 1 ] ; if ( _rtP -> P_109 > _rtP -> P_120 ) { _rtB -> B_25_102_816 [ 1 ] = _rtP -> P_107 [ 1 ] ; } else { _rtB -> B_25_102_816 [ 1 ] = _rtP -> P_108 [ 1 ] ; } _rtB -> B_25_89_712 [ 2 ] = _rtP -> P_108 [ 2 ] ; if ( _rtP -> P_109 > _rtP -> P_120 ) { _rtB -> B_25_102_816 [ 2 ] = _rtP -> P_107 [ 2 ] ; } else { _rtB -> B_25_102_816 [ 2 ] = _rtP -> P_108 [ 2 ] ; } _rtB -> B_25_105_840 = _rtP -> P_121 ; _rtB -> B_12_147_1176 = _rtP -> P_1 ; _rtB -> B_25_106_848 = _rtP -> P_122 ; _rtB -> B_21_123_984 = _rtP -> P_10 ; _rtB -> B_21_124_992 = _rtP -> P_11 ; _rtB -> B_21_125_1000 = _rtP -> P_12 ; _rtB -> B_21_126_1008 = _rtP -> P_13 ; _rtB -> B_25_107_856 = _rtP -> P_123 ; _rtB -> B_25_108_864 = _rtP -> P_124 ; _rtB -> B_25_109_872 = _rtP -> P_125 ; _rtB -> B_25_110_880 = _rtP -> P_126 ; _rtB -> B_25_111_888 = _rtP -> P_127 ; _rtB -> B_25_112_896 = _rtP -> P_128 ; _rtB -> B_25_113_904 = _rtP -> P_129 ; _rtB -> B_25_114_912 = _rtP -> P_130 ; _rtB -> B_25_115_920 = _rtP -> P_131 ; UNUSED_PARAMETER ( tid ) ; }
#define MDL_UPDATE
static void mdlUpdate ( SimStruct * S , int_T tid ) {
B_Hall_sensor_120deg_filter_org_T * _rtB ; DW_Hall_sensor_120deg_filter_org_T
* _rtDW ; P_Hall_sensor_120deg_filter_org_T * _rtP ;
X_Hall_sensor_120deg_filter_org_T * _rtX ; int32_T isHit ; _rtDW = ( ( DW_Hall_sensor_120deg_filter_org_T * ) ssGetRootDWork ( S ) ) ; _rtX = ( ( X_Hall_sensor_120deg_filter_org_T * ) ssGetContStates ( S ) ) ; _rtP = ( ( P_Hall_sensor_120deg_filter_org_T * ) ssGetModelRtp ( S ) ) ; _rtB = ( ( B_Hall_sensor_120deg_filter_org_T * ) _ssGetModelBlockIO ( S ) ) ; isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtDW -> DiscreteTimeIntegrator2_DSTATE += _rtP -> P_19 * _rtB -> B_25_64_512 ; _rtDW -> DiscreteTimeIntegrator1_DSTATE += _rtP -> P_21 * _rtB -> B_25_66_528 ; ssCallAccelRunBlock ( S , 25 , 8 , SS_CALL_MDL_UPDATE ) ; } { real_T * * uBuffer = ( real_T * * ) & _rtDW -> VariableTransportDelay_PWORK . TUbufferPtrs [ 0 ] ; real_T simTime = ssGetT ( S ) ; boolean_T bufferisfull = false ; _rtDW -> VariableTransportDelay_IWORK . Head = ( ( _rtDW -> VariableTransportDelay_IWORK . Head < ( _rtDW -> VariableTransportDelay_IWORK . CircularBufSize - 1 ) ) ? ( _rtDW -> VariableTransportDelay_IWORK . Head + 1 ) : 0 ) ; if ( _rtDW -> VariableTransportDelay_IWORK . Head == _rtDW -> VariableTransportDelay_IWORK . Tail ) { bufferisfull = true ; if ( ! Hall_sensor_120deg_filter_org_acc_rt_TDelayUpdateTailOrGrowBuf ( & _rtDW -> VariableTransportDelay_IWORK . CircularBufSize , & _rtDW -> VariableTransportDelay_IWORK . Tail , & _rtDW -> VariableTransportDelay_IWORK . Head , & _rtDW -> VariableTransportDelay_IWORK . Last , simTime - _rtP -> P_43 , uBuffer , ( boolean_T ) 1 , ( boolean_T ) 1 , & _rtDW -> VariableTransportDelay_IWORK . MaxNewBufSize ) ) { ssSetErrorStatus ( S , ( char_T * ) "\"vtdelay memory allocation error\"" ) ; return ; } } ( * uBuffer + _rtDW -> VariableTransportDelay_IWORK . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK . Head ] = simTime ; ( * uBuffer + 2 * _rtDW -> VariableTransportDelay_IWORK . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK . Head ] = _rtX -> VariableTransportDelay_CSTATE ; ( * uBuffer ) [ _rtDW -> VariableTransportDelay_IWORK . Head ] = _rtB -> B_25_37_296 ; if ( bufferisfull ) { ssSetBlockStateForSolverChangedAtMajorStep ( S ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( S ) ; } } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtDW -> Memory_PreviousInput = _rtB -> B_25_39_312 ; _rtDW -> Integrator_DSTATE += _rtP -> P_52 * _rtB -> B_25_59_472 ; _rtDW -> Filter_DSTATE += _rtP -> P_55 * _rtB -> B_25_41_328 ; } { real_T * * uBuffer = ( real_T * * ) & _rtDW -> VariableTransportDelay_PWORK_j . TUbufferPtrs [ 0 ] ; real_T simTime = ssGetT ( S ) ; boolean_T bufferisfull = false ; _rtDW -> VariableTransportDelay_IWORK_n . Head = ( ( _rtDW -> VariableTransportDelay_IWORK_n . Head < ( _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize - 1 ) ) ? ( _rtDW -> VariableTransportDelay_IWORK_n . Head + 1 ) : 0 ) ; if ( _rtDW -> VariableTransportDelay_IWORK_n . Head == _rtDW -> VariableTransportDelay_IWORK_n . Tail ) { bufferisfull = true ; if ( ! Hall_sensor_120deg_filter_org_acc_rt_TDelayUpdateTailOrGrowBuf ( & _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize , & _rtDW -> VariableTransportDelay_IWORK_n . Tail , & _rtDW -> VariableTransportDelay_IWORK_n . Head , & _rtDW -> VariableTransportDelay_IWORK_n . Last , simTime - _rtP -> P_63 , uBuffer , ( boolean_T ) 1 , ( boolean_T ) 1 , & _rtDW -> VariableTransportDelay_IWORK_n . MaxNewBufSize ) ) { ssSetErrorStatus ( S , ( char_T * ) "\"vtdelay memory allocation error\"" ) ; return ; } } ( * uBuffer + _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK_n . Head ] = simTime ; ( * uBuffer + 2 * _rtDW -> VariableTransportDelay_IWORK_n . CircularBufSize ) [ _rtDW -> VariableTransportDelay_IWORK_n . Head ] = _rtX -> VariableTransportDelay_CSTATE_g ; ( * uBuffer ) [ _rtDW -> VariableTransportDelay_IWORK_n . Head ] = _rtB -> B_25_43_344 ; if ( bufferisfull ) { ssSetBlockStateForSolverChangedAtMajorStep ( S ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( S ) ; } } isHit = ssIsSampleHit ( S , 1 , 0 ) ; if ( isHit != 0 ) { _rtDW -> Memory_PreviousInput_d = _rtB -> B_25_45_360 ; _rtDW -> DiscreteTimeIntegrator1_DSTATE_n += _rtP -> P_66 * _rtB -> B_25_106_848 ; if ( _rtB -> B_25_47_376 > 0.0 ) { _rtDW -> DiscreteTimeIntegrator1_PrevResetState = 1 ; } else if ( _rtB -> B_25_47_376 < 0.0 ) { _rtDW -> DiscreteTimeIntegrator1_PrevResetState = - 1 ; } else if ( _rtB -> B_25_47_376 == 0.0 ) { _rtDW -> DiscreteTimeIntegrator1_PrevResetState = 0 ; } else { _rtDW -> DiscreteTimeIntegrator1_PrevResetState = 2 ; } _rtDW -> DelayInput1_DSTATE = _rtB -> B_13_146_1168 ; } isHit = ssIsSampleHit ( S , 2 , 0 ) ; if ( isHit != 0 ) { _rtDW -> UnitDelay_DSTATE = _rtB -> B_25_72_576 ; } UNUSED_PARAMETER ( tid ) ; }
#define MDL_UPDATE
static void mdlUpdateTID3 ( SimStruct * S , int_T tid ) { UNUSED_PARAMETER ( tid
) ; }
#define MDL_DERIVATIVES
static void mdlDerivatives ( SimStruct * S ) {
B_Hall_sensor_120deg_filter_org_T * _rtB ; P_Hall_sensor_120deg_filter_org_T
* _rtP ; XDot_Hall_sensor_120deg_filter_org_T * _rtXdot ;
X_Hall_sensor_120deg_filter_org_T * _rtX ; _rtXdot = ( ( XDot_Hall_sensor_120deg_filter_org_T * ) ssGetdX ( S ) ) ; _rtX = ( ( X_Hall_sensor_120deg_filter_org_T * ) ssGetContStates ( S ) ) ; _rtP = ( ( P_Hall_sensor_120deg_filter_org_T * ) ssGetModelRtp ( S ) ) ; _rtB = ( ( B_Hall_sensor_120deg_filter_org_T * ) _ssGetModelBlockIO ( S ) ) ; _rtXdot -> Integrator_CSTATE = _rtB -> B_25_32_256 ; _rtXdot -> MechSystem_CSTATE = 0.0 ; _rtXdot -> MechSystem_CSTATE += _rtP -> P_34 * _rtX -> MechSystem_CSTATE ; _rtXdot -> MechSystem_CSTATE += _rtB -> B_25_67_536 ; _rtXdot -> Integrator_CSTATE_n = _rtB -> B_25_54_432 ; { real_T instantDelay ; instantDelay = _rtB -> B_25_55_440 ; if ( instantDelay > _rtP -> P_43 ) { instantDelay = _rtP -> P_43 ; } if ( instantDelay < 0.0 ) { _rtXdot -> VariableTransportDelay_CSTATE = 0 ; } else { _rtXdot -> VariableTransportDelay_CSTATE = 1.0 / instantDelay ; } } _rtXdot -> Integrator_CSTATE_l = _rtB -> B_23_118_944 ; { real_T instantDelay ; instantDelay = _rtB -> B_25_56_448 ; if ( instantDelay > _rtP -> P_63 ) { instantDelay = _rtP -> P_63 ; } if ( instantDelay < 0.0 ) { _rtXdot -> VariableTransportDelay_CSTATE_g = 0 ; } else { _rtXdot -> VariableTransportDelay_CSTATE_g = 1.0 / instantDelay ; } } _rtXdot -> Filter_CSTATE = _rtB -> B_25_58_464 ; _rtXdot -> Integrator_CSTATE_j = _rtB -> B_25_57_456 ; } static void mdlInitializeSizes ( SimStruct * S ) { ssSetChecksumVal ( S , 0 , 1512797602U ) ; ssSetChecksumVal ( S , 1 , 2081295745U ) ; ssSetChecksumVal ( S , 2 , 3965149879U ) ; ssSetChecksumVal ( S , 3 , 3295229541U ) ; { mxArray * slVerStructMat = ( NULL ) ; mxArray * slStrMat = mxCreateString ( "simulink" ) ; char slVerChar [ 10 ] ; int status = mexCallMATLAB ( 1 , & slVerStructMat , 1 , & slStrMat , "ver" ) ; if ( status == 0 ) { mxArray * slVerMat = mxGetField ( slVerStructMat , 0 , "Version" ) ; if ( slVerMat == ( NULL ) ) { status = 1 ; } else { status = mxGetString ( slVerMat , slVerChar , 10 ) ; } } mxDestroyArray ( slStrMat ) ; mxDestroyArray ( slVerStructMat ) ; if ( ( status == 1 ) || ( strcmp ( slVerChar , "24.2" ) != 0 ) ) { return ; } } ssSetOptions ( S , SS_OPTION_EXCEPTION_FREE_CODE ) ; if ( ssGetSizeofDWork ( S ) != ( SLSize ) sizeof ( DW_Hall_sensor_120deg_filter_org_T ) ) { static char msg [ 256 ] ; snprintf ( msg , 256 , "Unexpected error: Internal DWork sizes do " "not match for accelerator mex file (%ld vs %lu)." , ( signed long ) ssGetSizeofDWork ( S ) , ( unsigned long ) sizeof ( DW_Hall_sensor_120deg_filter_org_T ) ) ; ssSetErrorStatus ( S , msg ) ; } if ( ssGetSizeofGlobalBlockIO ( S ) != ( SLSize ) sizeof ( B_Hall_sensor_120deg_filter_org_T ) ) { static char msg [ 256 ] ; snprintf ( msg , 256 , "Unexpected error: Internal BlockIO sizes do " "not match for accelerator mex file (%ld vs %lu)." , ( signed long ) ssGetSizeofGlobalBlockIO ( S ) , ( unsigned long ) sizeof ( B_Hall_sensor_120deg_filter_org_T ) ) ; ssSetErrorStatus ( S , msg ) ; } { int ssSizeofParams ; ssGetSizeofParams ( S , & ssSizeofParams ) ; if ( ssSizeofParams != sizeof ( P_Hall_sensor_120deg_filter_org_T ) ) { static char msg [ 256 ] ; snprintf ( msg , 256 , "Unexpected error: Internal Parameters sizes do " "not match for accelerator mex file (%d vs %lu)." , ssSizeofParams , ( unsigned long ) sizeof ( P_Hall_sensor_120deg_filter_org_T ) ) ; ssSetErrorStatus ( S , msg ) ; } } _ssSetModelRtp ( S , ( real_T * ) & Hall_sensor_120deg_filter_org_rtDefaultP ) ; _ssSetConstBlockIO ( S , & Hall_sensor_120deg_filter_org_rtInvariant ) ; } static void mdlInitializeSampleTimes ( SimStruct * S ) { { SimStruct * childS ; SysOutputFcn * callSysFcns ; childS = ssGetSFunction ( S , 0 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 1 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 2 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 3 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 4 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 5 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 6 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 7 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 8 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 9 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 10 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 11 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; childS = ssGetSFunction ( S , 12 ) ; callSysFcns = ssGetCallSystemOutputFcnList ( childS ) ; callSysFcns [ 3 + 0 ] = ( SysOutputFcn ) ( NULL ) ; } slAccRegPrmChangeFcn ( S , mdlOutputsTID3 ) ; } static void mdlTerminate ( SimStruct * S ) { }
#include "simulink.c"
